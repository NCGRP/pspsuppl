#use 'grenedalf frequency' to pass SNP frequencies to DAPC for pop structure analysis,
#Bvm64pool and MitchSeqpools


### NOTES ON DAPC ###
dapc uses no scaling for the pca.  this is weird.  dapc changes missing data to the mean
of the variable.  in the case of SNPs the mean value equals zero while the reference and
alternate allele receive values distributed on both sides of zero (one positive, one
negative).  this is weird.  it could cause samples with lots of missing data to cluster 
artifactually, see Jombart warning: https://lists.r-forge.r-project.org/pipermail/adegenet-forum/2015-September/001267.html
### END NOTES ON DAPC ###


### CALCULATE ALLELE FREQUENCIES USING GRENEDALF ###

cd /90daydata/patellifolia/MitchSeq/bam; #on atlas, 10 hrs
b=$(ls [SB][Rv]*.bam | tr '\n' ' ' | sed 's/ $//'); #use 196 mapped mitchseq data sets plus Bvm64
p=ms197; #mitchseq 196 mapped accessions plus Bvm64
export p;
sbatch --job-name="gdalffreq" -p atlas --account=patellifolia \
       -N 1 -n 48 -t 4-00:00:00 -e "stderr.%j.%N.%A.%a" \
       --wrap="echo $b 1>&2; \
               time grenedalf frequency \
                   --sam-path $b \
                   --reference-genome-fai /project/patellifolia/Bvulgaris/refgenomes/EL10.2.fa.fai \
                   --make-gapless \
                   --write-sample-ref-freq \
                   --write-sample-counts \
                   --write-total-counts \
                   --allow-file-overwriting \
                   --verbose \
                   --threads 48 \
                   --file-prefix "$p"_freq \
                   --log-file "$p"_freqlog.txt;
     "

#for 197 samples, the result file is 704GB with Bvm64 included and depth counts
#"Processed 569269539 genome positions of the input file, from 20 chromosomes, and thereof skipped 100782451 due to being invariant sites."
#output like:
#CHROM,POS,REF,ALT,Bvm64.REF_CNT,Bvm64.ALT_CNT,Bvm64.FREQ,SRR10059367.REF_CNT,SRR10059367.ALT_CNT,...,TOTAL.REF_CNT,TOTAL.ALT_CNT

#filter it to high quality loci
time wc -l "$p"_freqfrequency.csv; #21 min, output has 468487089, reported in slurm*.out by grenedalf, superfluous step,

#remove loci with missing data
time grep -v nan "$p"_freqfrequency.csv > "$p"_nonan.csv; #36 min, 
wc -l "$p"_nonan.csv; #316034040 lines


#examine the distribution of alternate allele frequencies across the sample of 197
time tail -n+2 "$p"_nonan.csv | awk -F, -v OFMT='%.4f' '{print $NF/$(NF-1)}' > "$p"_altf.txt; #print 4 decimal places, no scientific, 2.75 hr
sort "$p"_altf.txt | uniq -c > "$p"_altf.hist.txt; #make a histogram

#alt allele distribution shows many low frequency (<0.001) loci, these are probably errors

#Filtering based on maf needs to be done at the level of the sample, not the population.
#Likewise for filtering on depth.

#filter on read depth like:
                   --filter-sample-min-count 2 \
                   --filter-sample-min-read-depth 4 \
                   --filter-sample-max-read-depth 10000 \
#output like:
#CHROM,POS,REF,ALT,Bvm64.REF_CNT,Bvm64.ALT_CNT,Bvm64.FREQ,SRR10059367.REF_CNT,SRR10059367.ALT_CNT,...,TOTAL.REF_CNT,TOTAL.ALT_CNT


#procedure to eliminate singleton loci marks the REF_CNT column with "exc" if neither ref or alt counts are >=2
mc=2; #mincount, exclude if no allele has 2 or more reads, i.e. exclude singleton loci
time awk -F, -v mc=$mc '{ for (i=5;i<=NF;i=i+3) if ($i < mc && $(i+1) < mc) $i = "exc"; print }' "$p"_nonan.csv | tr ',' ' ' | grep -v "exc" > "$p"_nonan_mc"$mc".tmp; #5.7 hrs
wc -l "$p"_nonan_mc"$mc".tmp; #301606479 loci with no singleton calls


#extract the frequency columns
ncol2=$(head -1 "$p"_nonan_mc"$mc".tmp | tr ' ' '\n' | wc -l); #number of columns
fcols=$(seq 7 3 $ncol2 | tr '\n' ',' | sed 's/,$//'); #cols with freq data
fcols="1-4,$fcols"; #add columns with row labels
cut -d' ' -f"$fcols" "$p"_nonan_mc"$mc".tmp > "$p"_nonan_mc"$mc".txt;

#make histogram of frequencies with singletons disallowed
time tail -n+2 "$p"_nonan_mc"$mc".tmp | awk -F' ' -v OFMT='%.4f' '{print $NF/$(NF-1)}' > "$p"_nonan_mc"$mc"_altf.txt; #print 4 decimal places, no scientific, 60 min
sort "$p"_nonan_mc"$mc"_altf.txt | uniq -c > "$p"_nonan_mc"$mc"_altf.hist.txt; #make a histogram

#most loci have alternate allele frequencies less than 0.001, even after removing singletons. These are probably errors
#filtering for singletons appears to have controlled for elevated peaks at frequencies like 1/8, 1/4

#clean up
rm "$p"_nonan_mc"$mc".tmp;


#set a minor allele frequency cutoff, then remove fixed monomorphic sites
maf=0.95;
ncol=$(head -1 "$p"_nonan_mc"$mc".txt | cut -d' ' -f5- | tr ' ' '\n' | wc -l); #number of samples
ref1=$(for ((i=1; i<=$ncol; i++)); do echo -n ' 1'; done;) #search pattern for monomorphic ref allele
alt1=$(for ((i=1; i<=$ncol; i++)); do echo -n ' 0'; done;) #search pattern for monomorphic alt allele

time awk -F' ' -v maf=$maf '{ for (i=5;i<=NF;i++) if ($i > maf) $i = 1; print }' "$p"_nonan_mc"$mc".txt | grep -v "$ref1"$ > "$p"_nonan_mc"$mc"_maf"$maf".tmp; #2 hrs 40 min
wc -l "$p"_nonan_mc"$mc"_maf"$maf".tmp; #ms197 41424198
time awk -F' ' -v maf=$maf '{ for (i=5;i<=NF;i++) if ($i < 1-maf) $i = 0; print }' "$p"_nonan_mc"$mc"_maf"$maf".tmp | grep -v "$alt1"$ > "$p"_nonan_mc"$mc"_maf"$maf".csv; #23 min
wc -l "$p"_nonan_mc"$mc"_maf"$maf".csv; #ms197 41424198
rm "$p"_nonan_mc"$mc"_maf"$maf".tmp;



#subsample some reasonable number of loci
mypp() {
        nloci=$1
        fn="$p"_nonan_mc"$mc"_maf"$maf"; #file name base
        header=$(head -1 "$p"_nonan_mc"$mc".txt | sed 's/\.FREQ//g' | tr ',' ' ');
        time shuf "$fn".csv | head -"$nloci"000  | sort -t' ' -k1,1 -k2,2n > "$fn"_"$nloci".tmp.txt; #12 min
        echo "$header" > "$fn"_"$nloci".tmp1.txt;
        cat "$fn"_"$nloci".tmp.txt >> "$fn"_"$nloci".tmp1.txt;
        rh=$(cut -d' ' -f1-2 "$fn"_"$nloci".tmp1.txt | sed 's/ /\./'); #row header
        paste -d' ' <(echo "$rh") <(cut -d' ' -f5- "$fn"_"$nloci".tmp1.txt) > "$fn"_"$nloci"k.csv;
        rm "$fn"_"$nloci".tmp.txt "$fn"_"$nloci".tmp1.txt;
}
export -f mypp

p="ms197";
mc=2
maf=0.95;
export p mc maf;
nloci="2000"; # x thousand loci, space delimited list like "1000 500 250 150"
time echo "$nloci" | tr ' ' '\n' | parallel --jobs 1 --env mypp mypp; #about 12 minutes per <1M loci, 1hr for 20M loci 


#clean up a little
mkdir /90daydata/patellifolia/MitchSeq/dapc;
cp "$p"_nonan_mc"$mc"_maf"$maf".csv ../dapc;
mv "$p"_nonan_mc"$mc"_maf"$maf"_*k.csv ../dapc;




#rename samples
#to label by program use '{print $1"_"$4}' or '{print $3"_"$5}'
#to label by type use '{print $3"_"$2}'

v="ms197";
mc=2;
maf=0.95;
nloci=3000; #x thousands of loci
nsamp=197;

cd /90daydata/patellifolia/MitchSeq/dapc;
dm="$v"_nonan_mc"$mc"_maf"$maf"_"$nloci"k;  #file name prefix
b=$(head -1 "$dm".csv | tr ' ' '\n'); #sample names
for i in $b;
  do echo "$i";
    j=$(grep ^$i$'\t' renamer.txt | awk -F$'\t' '{print $3"_"$5}' | sed 's/ //g' | sed 's/-//g'); #new name
    b1=$(echo "$b" | sed 's/^'$i'$/'$j'/');
    b="$b1";
 done;

echo -n "CHROM.POS" > "$dm".csv1;
echo "$b" | tr '\n' ' ' | sed 's/ $//g' >> "$dm".csv1;
echo >> "$dm".csv1;
time tail -n+2 "$dm".csv >> "$dm".csv1; #3min
mv "$dm".csv1 "$dm".renamedPROG.csv;


#remove non-sugar beet types
bb=$(head -1 "$dm".renamedPROG.csv | tr ' ' '\n' | nl -nln | tr '\t' ' ' | sed 's/  */ /g' | grep -v "_na"$); #remove wild, table, fodder and leaf types using 'na' for location
#remove a lingering table beet and maritima type accessions (including F1s)
b=$(echo "$bb" | grep -v " WisconsinBreedingLine_WI" | grep -v " PI564243_" \
               | grep -v " PI586688_" | grep -v " PI687276_" | grep -v " PI655307_" | grep -v " PI655308_" \
               | grep -v " PI655305_"| grep -v " PI654357_"); 
head -1 "$dm".renamedPROG.csv | tr ' ' '\n' | wc -l; #198 = 197 acc + header
echo "$bb" | wc -l; #168 = 167 acc + header
echo "$b" | wc -l; #161 = 159 acc of sugar beet + header

#get the index of columns to keep
ind=$(echo "$b" | cut -d' ' -f1 | tr '\n' ',' | sed 's/,$//');

#write the data set with only sugar beets
time cut -d' ' -f $ind  "$dm".renamedPROG.csv > "$dm".renamedPROG.sugaronly.csv; #2min, or 26 min

^^^URHERE


#on mini
cd /Volumes/Public/Data/PatReeves/MitchSeq/GrenedalfToDAPC;
p="ms197";
mc=2
maf=0.95;
nloci=50; # x thousand loci
rsync -aP pat.reeves@atlas-login.hpc.msstate.edu:"/90daydata/patellifolia/MitchSeq/dapc/"$p"_nonan_mc"$mc"_maf"$maf"_*k.csv" .;


### END CALCULATE ALLELE FREQUENCIES USING GRENEDALF ###






### ITERATE DAPC OVER K ###


### BEGIN R ###
#install.packages("adegenet")
#install.packages("polysat")
#install.packages("rgl")
library(rgl)
library(adegenet)
library(polysat)
library(RColorBrewer)
library(ape)

options(error = recover)
rm(list=ls()) 
origpar=par() #collect the original settings
par(bg='white') #in case you want to cut and paste from quartz window, otherwise blacked out

#highly constrasting color palette
c25 <- c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A", "#FF7F00", "black", "gold1", "skyblue2", "#FB9A99", "palegreen2", "#CAB2D6", "#FDBF6F", "gray70", "khaki2", "maroon", "orchid1", "deeppink1", "blue1", "steelblue4", "darkturquoise", "green1", "yellow4", "yellow3", "darkorange4", "brown");

## FUNCTIONS

myDAPC=function(C2) {

	#center the data matrix using scale(), set all NA to 0, as dapc would do 
	Y <- scale(C2, center = TRUE, scale = sc) #dapc centers, but does not scale by default
	Y[is.na(Y)] = 0 #set all NA to 0
	
	#determine some reasonable number of clusters for the data, other than the population designations
	#this uses Kmeans clustering to assign individuals to genetic clusters, I think it might be
	#used as a prior. It lets you set the number of clusters based on a plot that minimizes BIC.
	#Optimal cluster number selection can be automated under various criteria.
	#system.time(Ygrp <- find.clusters.matrix(Y,max.n.clust=25,method="ward",scale=sc)) #20 min, interactive run to determine optimal K, 7 looks best for ms197, 6 for sugar beet only (159)
	Ygrp <- find.clusters.matrix(Y,n.pca=10000,max.n.clust=25,method="ward",scale=sc,n.clust=K) #run for a single K
		
	#run dapc
	maxRank = min(dim(C2)) #set n.pca to smaller of nind or nloci
	Ydapc1<-dapc.matrix(Y,Ygrp$grp,n.da=nda,n.pca=maxRank,scale=sc) #keep maxRank PCs, and nda discriminant functions
	
	#make the compoplot manually, for better control of labeling
	pdf(paste(p,".",nrow(Ydapc1$tab),".K",ncol(Ydapc1$posterior),".",nloci,"K",suf,".pdf",sep=""), width=20, height=2, pointsize=7)
#	barplot(t(Ydapc1$posterior), col = sample(c25), #select colors randomly
	barplot(t(Ydapc1$posterior), col = c25,
						   ylab = "membership probability", legend.text=TRUE,
						   border=NA, 
						   names.arg=rownames(Ydapc1$posterior), las=3, cex.names=0.6,
						   width=4, xlim=c(0,1000))
	dev.off()


	
	return(Ydapc1)
}


## MAIN

setwd("/Volumes/Public/Data/PatReeves/MitchSeq/GrenedalfToDAPC")
p="ms197" #prefix for input and output file names
mc=2
maf=0.95
nloci=3000 # x thousand loci, 20M breaks the memory, 10M is ok to read in, 5M crashes dapc, 1M works
suf=".renamedPROG" #suffix for i/o file names "", ".renamedPROG.sugaronly", ".renamedTYPE", ".renamedPROG"

shrink=FALSE #shrink data set each iteration by removing exclusive assignments (TRUE,FALSE). If TRUE, K is determined automatically
K=10 #initial K value to consider, only set to integer when shrink==FALSE, otherwise set to K=NULL
Kmin=2 #final K value to consider
if(shrink==TRUE) {K=NULL} #automatically set K=NULL when shrink=TRUE
exc=0.99 #value to indicate an exclusive assignment, used when shrink=TRUE
sc=FALSE #scale the data by using sc=TRUE, this may hyper-resolve the data. to use dapc default set sc=FALSE
nda=2 #number of discriminant functions to use


#read in data set in grenedalf allele frequency output format
#note this transposes the matrix on import
#C <- t(read.table(paste(p,"_nonan_mc",mc,"_maf",maf,"_",nloci,"k.csv",sep=""), header=TRUE, row.names=1, sep=" "))
C <- t(read.table(paste(p,"_nonan_mc",mc,"_maf",maf,"_",nloci,"k",suf,".csv",sep=""), header=TRUE, row.names=1, sep=" "))


#	#take a break from dapc to calculate a distance matrix from the allele frequencies
#	#for the original loaded data set (for splitstree eventually)
#	dm=dist(C, method = "euclidean", diag = TRUE, upper = TRUE) #takes ~1hr for 10E6 loci
#	tre <- nj(dm) #make nj tree just to verify frequency data processed as expected
#	plot(tre, cex = 0.6) #inspect nj tree
#	
#	#export as full triangle matrix with diagonal
#	dmdf=as.data.frame(as.matrix(dm)) #convert distance matrix to data frame
#	write.csv(dmdf,file=paste(p,".",nrow(C),".",nloci,"K.distmatrix.txt",sep="")) #write data frame to csv file, this will be used for splitstree pipeline


#return to dapc pipeline, 5M breaks memory of this step
system.time( {Ydapc1=myDAPC(C)} ) #initial DAPC run



C2=C #swap variable name to set up for loop

repeat {
	if (shrink==TRUE) {
		#iteratively remove rows with exclusive assignments, defined as the presence of a single '1' in the Q matrix
		toexclude=rownames(Ydapc1$posterior[rowSums(Ydapc1$posterior >= exc) == 1,]) #identify samples assigned to one population with a probability > exc
		
		if(length(toexclude)==nrow(Ydapc1$posterior)) { break } #quit if there will be no samples left after the current removal
		
		Ctmp=C2[!(row.names(C2) %in% toexclude),] #remove rows
		C2=Ctmp #update loop variable C2
	} else if (shrink==FALSE) {
		K=K-1
		if(K<Kmin) { break } #quit when K=1
	}
		
	Ydapc1=myDAPC(C2)
}



^^^URHERE



#plot distribution of smallest reference allele frequencies in each locus
minbylocus=apply(C2, 2, FUN = min) #get minimum value from each row
w=hist(minbylocus,xlim=c(0,1),labels=TRUE)
plot(w) #this suggests you might want to do a maf>0.85
v=density(minbylocus)
plot(v)
peakx <- v$x[which(diff(sign(diff(v$y)))==-2)]

#major distinct peaks at -0.003014384  0.497952674  0.663611104  0.747438261  0.799331263
#a blur of two peaks from 0.835257187-0.871183112, suggesting a maf between 0.8 and 0.835


### END R ###


### END ITERATE DAPC OVER K ###


^^^URHERE, perhaps the iteration should proceed from 2 to K, with subsets of exclusive assignments split off and analyzed separately.

With sufficient nloci, dapc produces only exclusive assignments, with little suggestion of pseudo-admixture. 
Examination of trial runs suggests that dapc is an unstable procedure. 50K is clearly insufficient, up to 1000K loci still shows
some minor variation between randomly assembled datasets (but is generally much better).  Using n.da=2 (two discriminant functions)
and scale=TRUE may stabilize things further a bit. 
 
^^^LBNOTES, 6/27/25, uncovered a problem with 8 early samples of 100x 100n poolseq data. all but corner-camp come out as distinct clusters, they should be removed
In general, dapc is delivering only exclusive assignments, with for example, for K=2, all individuals but one
in a group, and for K =3, two individuals in their own distinct groups and everybody else in the third.
This is undesirable and may be related to the non-continuous distribution of reference allele
frequencies.

Try to figure this out by looking at a simple pco plot.  Does it look as expected based
on past analyses of diploid variant calls?

7/16/25. Partially resolved this issue by setting scale=FALSE, as is the dapc default, and
by eliminating loci with singleton reads. Still no indication of admixture, and the 8 100x
100n samples still mostly pop out alone (Broadus and CornerCamp do not)




### R CODE TO PERFORM PCA ON FREQUENCIES ###

#install.packages("rgl")
library(rgl)
library(adegenet)
library(ggplot2)

options(error = recover)
rm(list=ls()) 
origpar=par() #collect the original settings
par(bg='white') #in case you want to cut and paste from quartz window, otherwise blacked out

#highly constrasting color palette
c24 <- c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A", "#FF7F00", "gold1", "skyblue2", "#FB9A99", "palegreen2", "#CAB2D6", "#FDBF6F", "gray70", "khaki2", "maroon", "orchid1", "deeppink1", "blue1", "steelblue4", "darkturquoise", "green1", "yellow4", "yellow3", "darkorange4", "brown");
c25 <- c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A", "#FF7F00", "black", "gold1", "skyblue2", "#FB9A99", "palegreen2", "#CAB2D6", "#FDBF6F", "gray70", "khaki2", "maroon", "orchid1", "deeppink1", "blue1", "steelblue4", "darkturquoise", "green1", "yellow4", "yellow3", "darkorange4", "brown");

setwd("/Volumes/Public/Data/PatReeves/MitchSeq/GrenedalfToDAPC")
p="ms197" #prefix for input and output file names
mc=2
maf=0.95
nloci=3000 # x thousand loci, 20M breaks the memory, 10M is ok to read in, 5M crashes dapc, 1M works
suf=".renamedTYPE" #suffix for i/o file names ".renamedPROG.sugaronly", ".renamedTYPE", ""

#read in data set in grenedalf allele frequency output format
#note this transposes the matrix on import, so that rows are samples and columns are loci
C <- t(read.table(paste(p,"_nonan_mc",mc,"_maf",maf,"_",nloci,"k",suf,".csv",sep=""), header=TRUE, row.names=1, sep=" "))

maxRank <- min(dim(C)) #this is the smaller of rownum and colnum
#C.dudi = dudi.pca(C, center = TRUE, scale = FALSE, scannf = FALSE, nf=maxRank) #dapc uses scale=FALSE
D.dudi = dudi.pca(C, center = TRUE, scale = TRUE, scannf = FALSE, nf=maxRank) #use scale=TRUE


s=C.dudi$li
s=D.dudi$li
plot(s[,1:2])
text(x=s[,1], y=s[,2], labels=rownames(s), cex=0.65)

plot3d(x=s[,1], y=s[,2], z=s[,3])
rglwidget() #plots in a browser


C.eigenvalues=C.dudi$eig
C.percents=C.eigenvalues/sum(C.eigenvalues)

D.eigenvalues=D.dudi$eig
D.percents=D.eigenvalues/sum(D.eigenvalues)

cat("scale=FALSE", paste(p,"_nonan_mc",mc,"_maf",maf,"_",nloci,"k",suf,".csv",sep=""),C.percents[1:10])
cat("scale=TRUE", paste(p,"_nonan_mc",mc,"_maf",maf,"_",nloci,"k",suf,".csv",sep=""),D.percents[1:10])

#percent contribution summary
			scale=FALSE ms197_nonan_mc2_maf0.95_3000k.renamedPROG.sugaronly.csv 0.08669239 0.08134142 0.05451868 0.04541841 0.03705948 0.03270594 0.02665432 0.023346 0.02203523 0.02001049
			scale=TRUE ms197_nonan_mc2_maf0.95_3000k.renamedPROG.sugaronly.csv  0.03218307 0.02804439 0.02537298 0.02253723 0.02202725 0.02053892 0.01950045 0.01870267 0.01836665 0.01772369
			scale=FALSE ms197_nonan_mc2_maf0.95_3000k.renamedTYPE.csv 0.09825909 0.05804504 0.05541229 0.03816676 0.03552855 0.03188978 0.02612673 0.02318828 0.02060115 0.01758767
			scale=TRUE ms197_nonan_mc2_maf0.95_3000k.renamedTYPE.csv 0.05373277 0.03666629 0.02675759 0.02364914 0.02164501 0.01904533 0.01787065 0.01688856 0.01605353 0.01560935



#develop figure using scale=TRUE ms197_nonan_mc2_maf0.95_3000k.renamedTYPE.csv output in D.dudi
#color by beet type
s=D.dudi$li
type0=rownames(s)

#substitute "hybrid" for 6 "sugar" type accessions PI687276 PI655307 PI655308 PI655305 PI564243 PI654357
hybrids=c("PI687276","PI655307","PI655308","PI655305","PI564243","PI654357")
for(i in hybrids) {
  type0=sub(paste(i,"_sugar",sep=""), paste(i,"_hybrid",sep=""), type0)
}

#convert types to color codes
type1=strsplit(type0, split="_", fixed = TRUE)
type=sapply(type1,"[",2) #retrieve the second piece of the split string

ss=s #copy pca matrix to new variable
rownames(ss)=type0
ss$color=c24[as.numeric(as.factor(type))] #add color values to pca matrix based on numeric code for beet type
hybrid=grepl("hybrid",rownames(ss)) #boolean list TRUE for hybrid samples
sugar=grepl("sugar",rownames(ss)) #boolean list TRUE for hybrid samples

#plot pca axes 1x2 colored by beet type
plot(ss[,1:2], col="black", bg=ss$color, pch=21, cex=3, xlab="PCA1", ylab="PCA2")
text(x=ss[,1], y=ss[,2], labels=rownames(ss), cex=0.65)

#label hybrid and sugar types separately so you can read the names
plot(ss[,1:2], col="black", bg=ss$color, pch=21, cex=3, xlab="PCA1", ylab="PCA2")
text(x=ss[,1][hybrid], y=ss[,2][hybrid], labels=rownames(ss)[hybrid], cex=0.65)
text(x=ss[,1][sugar], y=ss[,2][sugar], labels=rownames(ss)[sugar], cex=0.65)


#plot pca axes 3x4 colored by beet type
plot(ss[,3:4], col="black", bg=ss$color, pch=21, cex=3, xlab="PCA3", ylab="PCA4")
text(x=ss[,3], y=ss[,4], labels=type0, cex=0.65)



#develop figure
#color by dapc assignment

myDAPCmini=function(C2) {
	Y <- scale(C2, center = TRUE, scale = sc) #dapc centers, but does not scale by default
	Y[is.na(Y)] = 0 #set all NA to 0
	Ygrp <- find.clusters.matrix(Y,n.pca=10000,max.n.clust=25,method="ward",scale=sc,n.clust=K) #run for a single K
	maxRank = min(dim(C2)) #set n.pca to smaller of nind or nloci
	Ydapc1<-dapc.matrix(Y,Ygrp$grp,n.da=nda,n.pca=maxRank,scale=sc) #keep maxRank PCs, and nda discriminant functions
	barplot(t(Ydapc1$posterior), col = c25,
						   ylab = "membership probability", legend.text=TRUE,
						   border=NA, 
						   names.arg=rownames(Ydapc1$posterior), las=3, cex.names=0.6,
						   width=4, xlim=c(0,1000))
	return(Ydapc1)
}
K=7 #optimal K
sc=FALSE
nda=2
Ydapc1=myDAPCmini(C)

p=Ydapc1$posterior #dapc assignment at K=7
pp=data.frame(row.names=rownames(p))
#substitute the cluster name for cluster assignment 1
for (i in 1:K) {
  c=paste0("c",i)
  pp[[i]]=gsub(1,i,p[,i])
}

colindex=as.data.frame(apply(pp, 1, function(x) x[x != 0])) #keep only the single non-zero value in each row
dapccols=c24[as.numeric(colindex[,1])] #get colors in reverse order so they don't conflict with 'type' plots

#run the pca
D.dudi = dudi.pca(C, center = TRUE, scale = TRUE, scannf = FALSE, nf=maxRank) #use scale=TRUE
s=D.dudi$li
ss=s #copy pca matrix to new variable
ss$dcolor=dapccols

#plot pca axes 1x2 colored by dapc assignment
plot(ss[,1:2], col="black", bg=ss$dcolor, pch=21, cex=3, xlab="PCA1", ylab="PCA2")
text(x=ss[,1], y=ss[,2], labels=rownames(ss), cex=0.65)

plot(ss[,3:4], col="black", bg=ss$dcolor, pch=21, cex=3, xlab="PCA3", ylab="PCA4")



#color unscaled pca by dapc clusters
gc() #clean up garbage

C.dudi = dudi.pca(C, center = TRUE, scale = FALSE, scannf = FALSE, nf=maxRank) #dapc uses scale=FALSE

s=C.dudi$li
type0=rownames(s)

#substitute "hybrid" for 6 "sugar" type accessions PI687276 PI655307 PI655308 PI655305 PI564243 PI654357
hybrids=c("PI687276","PI655307","PI655308","PI655305","PI564243","PI654357")
for(i in hybrids) {
  type0=sub(paste(i,"_sugar",sep=""), paste(i,"_hybrid",sep=""), type0)
}

#convert types to color codes
type1=strsplit(type0, split="_", fixed = TRUE)
type=sapply(type1,"[",2) #retrieve the second piece of the split string

ss=s #copy pca matrix to new variable
rownames(ss)=type0
ss$dcolor=dapccols

#plot pca axes 1x2 colored by dapc assignment
plot(ss[,1:2], col="black", bg=ss$dcolor, pch=21, cex=3, xlab="PCA1", ylab="PCA2")
points(ss[102,1:2], col = "black", bg="white", pch = 21, cex = 3)

plot(ss[102,1:2], col="black", bg=ss$dcolor, pch=21, cex=5, xlab="PCA1", ylab="PCA2")
text(x=ss[,1], y=ss[,2], labels=rownames(ss), cex=0.65)






plot(ss[,3:4], col="black", bg=ss$dcolor, pch=21, cex=3, xlab="PCA3", ylab="PCA4")


#print out a table of the dapc partition with the corrected hybrid names
partition=colindex #make a single data frame holding the partition with correct labels
partition$correctnames=rownames(ss)
write.table(partition, 'dapcpartition_Rexport.txt', append=FALSE)



### END R CODE TO PERFORM PCA ON FREQUENCIES ###




### PROCESS DAPC PARTITION ###

cd /Volumes/Public/Data/PatReeves/MitchSeq/GrenedalfToDAPC;
sed 's/\"//g' dapcpartition_Rexport.txt | tail -n+2 | awk -F' ' '{print $3" "$2}' \
  | sed 's/_/ /' | awk -F' ' '{print $2" "$1" "$3}' | sort -t' ' -k3,3n -k1,1 > dapcpartition.tmp;

#get breeding program
pi=$(cut -d' ' -f2 dapcpartition.tmp);
pi_prog=$(head -1 ms197_nonan_mc2_maf0.95_3000k.renamedPROG.csv | tr ' ' '\n' | tail -n+2); #pi_prog labels
pi_prog_ordered=$(for i in $pi;
                    do echo "$pi_prog" | grep ^"$i"_ | sed 's/_/ /';
                    done;)
paste -d' ' dapcpartition.tmp <(echo "$pi_prog_ordered") | awk -F' ' '{print $1" "$5" "$2" "$3}' \
  | sort -t' ' -k4,4n -k1,1 -k2,2 -k3,3 | tr ' ' '\t' > dapcpartition.txt;
rm dapcpartition.tmp

#paste dapcpartition.txt into Excel as a table

^^^URHERE



### END PROCESS DAPC PARTITION ###



### SPLITSTREE ###

#on mini
cd /Volumes/Public/Data/PatReeves/MitchSeq/GrenedalfToDAPC;
v="ms197";
mc=2;
maf=0.95;
nloci=5000; #x thousands of loci
nsamp=197;

dm="$p"."$nsamp"."$nloci"K;  #distance matrix file name prefix
mv "$dm".distmatrix.txt ../splitstree;

#convert to NEXUS DISTANCES block
cd /Volumes/Public/Data/PatReeves/MitchSeq/splitstree;


#write header
nt=$(( $(wc -l "$dm".distmatrix.txt | awk '{print $1}') - 1 )); #number of samples
echo '#nexus [SplitsTree6]

BEGIN DISTANCES;
TITLE 'Distances';
DIMENSIONS ntax='$nt';
FORMAT labels=left diagonal triangle=Both;
MATRIX' > "$dm".splitsin.txt;

#write matrix
tail -n+2 "$dm".distmatrix.txt | sed s/\"/\'/g | tr ',' ' ' | nl -nln -w1 -s'] ' | sed 's/^/[/' >> "$dm".splitsin.txt;

#write footer
echo ';
END;' >> "$dm".splitsin.txt;

#rename samples
#to label by program use '{print $1"_"$4}' or '{print $3"_"$5}'
#to label by type use '{print $1"_"$2}'

b=$(grep -A100000 ^MATRIX "$dm".splitsin.txt | cut -d' ' -f2 | tail -n+2 | tac | tail -n+3 | tac | sed 's/'\''//g'); #sample names
cp "$dm".splitsin.txt "$dm".splitsin.txt1;
for i in $b;
  do echo "$i";
    j=$(grep ^$i$'\t' renamer.txt | awk -F$'\t' '{print $3"_"$5}' | sed 's/ //g' | sed 's/-//g');
    sed 's/'$i'/'$j'/' "$dm".splitsin.txt1 > "$dm".splitsin.txtTMP;
    mv "$dm".splitsin.txtTMP "$dm".splitsin.txt1;
 done;
 
#clean up
mv "$dm".splitsin.txt1 "$dm".splitsin.renamed.txt;






#import manually into Splitstree, export as svg file











